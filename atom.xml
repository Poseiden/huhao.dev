<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胡皓 - 枪炮与代码</title>
  
  <subtitle>从士兵到软件匠人的侃侃而谈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huhao.dev/"/>
  <updated>2020-01-18T10:05:28.000Z</updated>
  <id>https://huhao.dev/</id>
  
  <author>
    <name>胡皓</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域驱动实战思考（三）：DDD的分段式协作设计</title>
    <link href="https://huhao.dev/posts/61190ae2/"/>
    <id>https://huhao.dev/posts/61190ae2/</id>
    <published>2020-01-18T10:05:28.000Z</published>
    <updated>2020-01-18T10:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我的<a href="https://huhao.dev/posts/58fe0824/">上一篇文章</a>中，给大家介绍了我在实践中对于DDD设计过程进行梳理的思考。本篇则是向大家整体介绍一下我的“DDD分段式协作设计”的步骤和内容。</p><p>同时，该方法的基准化操作手册，也在曾经的一篇文章中<a href="https://huhao.dev/posts/130bb570/">公开提供了下载</a>，可以作为更细化的内容进行参考和使用。</p><p><strong>由于DDD的相关概念和设计方法极多，相比其他市场上所能见到的操作手法，我在这里向大家所介绍的方法，更加聚焦如何能够确保达到“绝大多数人的60分”， 而非“极少数人的100分”，也就是说，我更加注重的是：</strong></p><ul><li><strong>步骤间的连贯性</strong></li><li><strong>方法的可操作性</strong></li><li><strong>实践的可落地性</strong></li><li><strong>与新技术的匹配性（例如云原生）</strong></li></ul><p><strong>为此，我尽可能的通过实战检验，在一些需要凭借经验进行综合判断的场景，尽可能的提供虽然不完美但是可以降低选择成本的唯一选项或解释，从而争取让一线实施人员避免“二选一”或“看具体情况再说”这样莫能两可的纠结。</strong></p><p>需要说明的是，不同的咨询师在实施DDD的设计过程中手法都不一样，我仅是从我所实施过的咨询项目出发，提供了一种经反复验证可工作的方式，并不代表本方法是唯一正确的。</p><p>在这里仅供参考，也欢迎大家进行交流。</p><a id="more"></a><h2 id="DDD解决的问题和办法"><a href="#DDD解决的问题和办法" class="headerlink" title="DDD解决的问题和办法"></a>DDD解决的问题和办法</h2><p>在介绍分段式设计之前，让我们回顾一下DDD希望解决的问题：</p><blockquote><p><strong>软件核心复杂性</strong></p></blockquote><p>所谓“复杂”，我根据实际观察总结的理解是：</p><ul><li>业务场景多</li><li>业务流程长</li><li>业务概念多</li></ul><p><strong>而具备以上这种特征的业务问题，其复杂度往往都会超出任何单独一个人的大脑所能够理解和处理的范围。</strong></p><p>在过去的单体架构时代，由于业务复杂度和技术复杂度都还处于与今天相比更加“简单”的阶段，所以很多时候，我们可能能够依赖少数“聪明的”系统架构师或者“十倍工程师”来通过“拍脑袋”解决问题。</p><p>而在今天，这个迈向“第四次工业革命”的时代，当“唯一不变的就是变化”所带来的高业务响应力要求，使得业务问题的复杂度越来越高，而技术复杂度也随着云原生和微服务架构产生了几何增长，甚至催生出了DevOps这样的运动时。对于一个要应对复杂业务挑战的大规模企业来说，依赖少数“聪明人”通过“拍脑袋”来解决问题则变得越来越不现实。</p><p>那怎么办才好呢？</p><p>这时候，我们需要做的事情，就是<strong>通过集体的力量来解决问题：</strong></p><ul><li><strong>通过协作的方式消除部门墙和角色墙，共同应对和分析复杂业务问题，设计解决方案，避免少数人“拍脑袋”；</strong></li><li><strong>通过领域驱动的方式，依据业务问题的边界（业务变化的边界）、人员沟通一致性的边界（概念变化的边界）以及弹性伸缩的边界（云原生需求的边界）来架构软件系统，实现业务架构和技术架构相匹配，从而通过业务变化来拉动架构，通过架构来响应业务变化。</strong></li></ul><p>这种设计方式所提倡的方法，与过去的“传统设计方法”（嗯，没错，说的就是瀑布式或者伪敏捷）的区别，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050456.png" alt="DDD与传统设计方法的对比"></p><p>而聚焦到DDD本身，DDD首先强调的就是我们应当从过去一上来就先考虑“数据模型和数据库表怎么设计”这种“面向技术进行架构”的方式，改为优先考虑“我们要解决的问题是什么”这种“面向业务进行架构”的方式。</p><p>为此，Eric Evans提出了如下三个DDD的核心原则，原文（《Domain-Driven Design Reference: Definitions and Pattern Summaries》）和我的解释图如下：</p><blockquote><ol><li><strong>Focus on the core domain.</strong>（聚焦核心域）</li><li><strong>Explore models in a creative collaboration of domain practitioners and software practitioners.</strong>（领域专家和软件专家通过创造性的协作探索模型）</li><li><strong>Speak a ubiquitous language within an explicitly bounded context.</strong>（利用明确且有边界的上下文统一语言）</li></ol></blockquote><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050540.png" alt="DDD核心原则"></p><p>而在DDD思想出现之前，人们进行基于面向对象思想（OO）的系统架构设计的时候，更多的是通过“用例分析法 + SOLID原则 + UML”的方式，基于业务描述中的名词和动词，利用近似“拍脑袋”和“凭经验”的方式来进行建模的，相信但凡长期从事面向对象设计的同行都会有所体会。</p><p>而在DDD思想出现和逐渐发展后，该思想使得人们能够从业务抽象、统一语言和问题域划分等多维度进行“更有套路”的面向对象分析，所以DDD被业内人士评价为：<strong>OO Done Right</strong>（正确的完成面向对象设计），如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050542.png" alt="DDD是更有套路的设计方式"></p><h2 id="DDD的分段式协作设计"><a href="#DDD的分段式协作设计" class="headerlink" title="DDD的分段式协作设计"></a>DDD的分段式协作设计</h2><p>在回顾了DDD所解决的问题和办法之后，让我们来看一看如何通过分段式的协作设计来驱动DDD在设计阶段的落地。</p><p>在我所使用的方法中，核心思想是：</p><blockquote><p><strong>通过协作设计，从问题澄清和统一共识出发，逐层递进和细化，实现从业务抽象，到领域建模，再到技术实现的阶段性落地。</strong></p></blockquote><p>由此思想出发，我将分段式设计过程拆分为以下几个阶段：</p><ul><li><strong>战略设计阶段：</strong>业务驱动，忽略技术实现细节，为系统架构设计提供业务边界对齐、弹性边界对齐和投资优先级的信息输入。</li><li><strong>战术设计阶段：</strong>基于战略设计的信息输出，进行进一步的抽象设计，作为战略设计和技术实现的过渡阶段，为技术实现提供基于抽象模型和业务服务划分的输入。</li><li><strong>技术实现阶段：</strong>基于战略设计和战术设计的信息输出，进行技术实现相关的设计，例如：技术性组件补全，技术选型，业务API详细设计，分层架构设计，领域模型类设计，数据库设计，制定测试策略……等等。</li></ul><p>接下来，我来分别说一说各个阶段的内容。</p><h3 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h3><p>在战略设计阶段，我们优先关注的是：<strong>开发团队对于业务问题理解上的一致性</strong>。</p><p>在这个过程中，“开发团队”指的是包含了“领域专家”在内的所有软件开发相关的关键角色，例如：客户、产品经理 / 项目经理、用户体验设计师、系统架构师、开发工程师、测试工程师、运维工程师、数据库管理员、安全专家……等等。</p><p>而“领域专家”，则是一个能力上的称呼，而非职务上的某种角色，“领域专家”指的是：<strong>对需要解决的业务问题具备最丰富的领域知识，能够帮助和指导开发团队进行分析和设计的那个人（也可能是多个人的组合）</strong>。</p><p>之所以需要这么完备的人员构成，是因为协作设计的核心是需要将设计过程“前置（Shift Left）”到软件开发价值流的早期，通过深入的碰撞、讨论来形成<strong>共识</strong>，通过共识驱动整个开发的价值流，减少因为缺乏共识导致的扯皮、返工等浪费。</p><p>在该阶段，这些人聚在一起，<strong>忽略技术实现细节</strong>，通过通力协作关注以下几件事：</p><ul><li><strong>业务梳理和抽象：</strong>通过事件风暴工作坊，对现实业务流程进行以系统实现为目的的抽象。</li><li><strong>限界上下文识别：</strong>通过统一语言（消除语言二义性），对抽象概念进行澄清、分类和查漏补缺，从而识别业务边界。</li><li><strong>问题子域识别</strong>：通过对问题域进行识别和澄清，划分问题边界和问题域类型，对架构设计提供投资优先级的参考。</li></ul><h4 id="业务梳理和抽象"><a href="#业务梳理和抽象" class="headerlink" title="业务梳理和抽象"></a>业务梳理和抽象</h4><p>首先，团队需要保证所有人对于业务所要解决的问题、业务场景和业务流程的理解是一致的，而这一点在实际中恰恰是绝大多数团队最为明显的“软肋”。在现实中，每个人脑子里面对于业务的理解都是不一致的，而每个人又无法看到对方的理解长什么样。所以，我们需要通过一种可视化的协作设计方式，利用不同颜色的便利贴、马克笔在大白纸上进行沟通和交流（俗称“糊墙”，我们这些DDD顾问经常自嘲为“糊墙师”）。</p><p>业务抽象可视化的方式有很多种，其中比较著名的是<a href="https://en.wikipedia.org/wiki/Object_Modeling_in_Color" target="_blank" rel="noopener">“四色建模（Color Modeling in Color）”</a>和<a href="https://en.wikipedia.org/wiki/Event_storming" target="_blank" rel="noopener">“事件风暴（Event Storming）”</a>。在这里，我所使用的是入门门槛更低，更“傻瓜”的事件风暴。</p><p>事件风暴是一种用于DDD的协作设计方法。该方法基于现实业务流程，以系统实现为视角，基于领域事件的发生时间线，通过一次只关注一个维度（分离关注点）的分层抽象方式，将现实业务流程进行抽象并转化为系统实现的业务逻辑，这些步骤包括：</p><ul><li>识别领域事件</li><li>识别决策命令</li><li>识别领域名词</li></ul><p><strong>通过使用事件风暴对业务进行梳理和抽象，能够统一团队认知，并为战术设计阶段的领域建模提供直接输入。</strong></p><p><em>PS：我所使用的事件风暴实施过程，由于经过了大量的实战检验、总结和持续调整，已经与事件风暴创造者Alberto Brandolini先生的现有方法大不相同，有关于Alberto版本的事件风暴相关信息，可以<a href="https://www.eventstorming.com/" target="_blank" rel="noopener">查看他的网站</a>。</em></p><p>业务梳理和抽象的产出物，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050210.png" alt="事件风暴"></p><h4 id="限界上下文识别"><a href="#限界上下文识别" class="headerlink" title="限界上下文识别"></a>限界上下文识别</h4><p>在业务梳理和抽象完成后，团队接下来需要做的，是将事件风暴工作坊过程中产出的领域名词和外部系统拿出来，根据概念的相关性和理解上的“二义性”，将它们分门别类，按照“限界上下文（Bounded Context）”划分清楚他们的概念边界。</p><p>限界上下文，是概念的边界，在该边界内，当我们去交流某个业务概念时，不会产生理解和认知上的歧义（二义性），限界上下文是统一语言的重要保证，同时也是业务问题最小粒度的划分。</p><p>然后，团队需要根据限界上下文间概念的依赖关系，对限界上下文进行进一步分析，画出它们之间的依赖关系，以便发现和识别一些典型的“设计坏味道”，例如：</p><ul><li>双向依赖：上下文之间缺少一层未被澄清的上下文，或者两个上下文其实可被合为一个；</li><li>循环依赖：任何一个上下文发生变更，依赖链条上的上下文均需要改变；</li><li>过深的依赖：自身依赖的信息不能直接从依赖者获取到，需要通过依赖者从其依赖的上下文获取并传递，依赖链路过长，依赖链条上的任何一个上下文发生变更，其链条后的任何一个上下文均可能需要改变；</li></ul><p><strong>通过对于限界上下文的划分和依赖关系的识别，团队能够实现软件架构在概念边界上的内聚和解耦。</strong></p><p><em>PS：我使用了限界上下文依赖关系，代替了人们常用的“限界上下文映射（Context Mapping）”，因为限界上下文的7种上下游映射关系，所反映的是团队间的各种协作关系，这一步是一个非常细化的分析过程，在战略设计这种宏观分析阶段，实际中非常难以提前识别和分析，因为很多时候团队都还没有。而绝大多数情况下，我们做限界上下文分析的时候，都是为了能够快速的指导系统业务模块或服务的划分，所以我从<a href="https://c4model.com/" target="_blank" rel="noopener">C4模型（C4 Model）</a>中找到了灵感，进行了简化和代替。</em></p><p>限界上下文识别过程的产出物，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050302.png" alt="限界上下文依赖关系"></p><h4 id="问题子域识别"><a href="#问题子域识别" class="headerlink" title="问题子域识别"></a>问题子域识别</h4><p>在战略设计阶段的最后，团队需要根据限界上下文识别的产出，按照“一个子域负责解决具有一个独立业务价值的问题”的原则，将限界上下文以“切蛋糕”的方式，划分到不同的问题子域（Subdomain）中，并按照以下三种不同的子域类型进行标注：</p><ul><li><strong>核心域（Core Domain）：</strong>是当前产品的核心差异化竞争力，是整个业务的盈利来源和基石，如果核心域不存在，那么整个业务就不能运作。对于核心域，需要投入最优势的资源（包括能力高的人），和做严谨良好的设计。</li><li><strong>通用子域（Generic Subdomain）：</strong>该类问题在界内非常常见，所以很可能有现成的解决方案，通过购买或简单修改的方式就可以使用。</li><li><strong>支撑子域（Supporting Subdomain）：</strong>该类问题解决的是支撑核心域运作的问题，其重要程度不如核心域，又不属于通用子域，具备强烈的个性化需求，难以在业内找到现成的解决方案，需要专门的团队定制开发。</li></ul><p>问题子域，是对业务问题的澄清和划分，同时也是对于资源投入优先级的重要参考，相对限界上下文来说，是对业务问题更大粒度的划分。</p><p><strong>通过对于子域进行识别、划分和类型标注，团队能够实现软件架构在业务边界上的内聚和解耦。</strong></p><p><em>PS：在DDD的概念中，限界上下文和问题子域是两个不同维度的概念，理论上来说并没有相互的依赖关系，为了能够方便操作和降低落地成本，依据实践效果，我刻意的选择了“一个子域包含多个限界上下文，一个上下文不得存在于多个子域”的方式。</em></p><p>问题子域识别过程的产出物，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050316.png" alt="问题子域划分"></p><h3 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h3><p>在战术设计阶段，我们优先关注的是：<strong>通过抽象模型和业务模块划分来承载业务抽象，为DDD从战略到实现进行过渡</strong>。</p><p>这时候，团队已经在战略设计阶段完成了对于业务问题的澄清和抽象，需要深入建模细节，探讨软件架构的更细粒度的设计。</p><p>在该阶段，开发团队需要<strong>继续忽略技术实现细节</strong>，做以下几件事：</p><ul><li><strong>领域建模：</strong>针对核心域内的业务概念进行领域建模，通过聚合、实体、值对象的识别，为技术实现中的面向对象设计提供参考。</li><li><strong>业务服务划分：</strong>基于战略设计的输出，结合“云原生思想”、“康威定律”和“逆康威定律”，划分具体的业务服务单元。</li><li><strong>业务服务接口能力识别：</strong>根据领域建模和业务服务划分的输出，确定每一个业务服务单元对外暴露的“必要”接口能力清单（忽略具体的协议、地址和数据结构）。</li></ul><h4 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h4><p>领域建模，是通过将业务抽象为以下几种抽象模型的方式，利用模型承载和响应业务的变化：</p><ul><li><strong>聚合（Aggregate）：</strong>负责封装业务逻辑，通过一致性边界和统一语言，内聚决策命令和领域事件，容纳并识别领域名词为以下不同的抽象模型：<ul><li><strong>实体（Entity）：</strong>是聚合的主干，具有唯一标识和生命周期。</li><li><strong>聚合根（Aggregate Root）：</strong>是一种实体，是聚合的根节点。</li><li><strong>值对象（Value Object）：</strong>是实体的附加业务概念，用来描述实体所包含的业务信息。</li></ul></li></ul><p>以上抽象模型，同属领域模型（Domain Model），是对业务的高度抽象，利用抽象模型作为业务和系统实现的核心联系，领域模型封装和承载了全部的业务逻辑，并通过聚合的方式保持业务的“高内聚，低耦合”。</p><p>在后续的技术实现过程中，聚合就是一种文件目录结构（例如：包、命名空间、模块），里面存放了领域模型相关组件及其他的领域层组件，例如：领域服务（Domain Service），工厂（Factory），仓储接口（Repository）等。</p><p>领域建模中的聚合，在承载业务逻辑的同时，是对业务问题最细粒度的澄清和划分，一个限界上下文可能包含多个聚合，一个聚合不能存在于多个限界上下文。</p><p><strong>通过领域建模和对聚合的设计，团队能够实现软件架构在模型层面上的内聚和解耦。</strong></p><p>领域建模过程的产出物，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050342.png" alt="领域建模"></p><h4 id="业务服务识别"><a href="#业务服务识别" class="headerlink" title="业务服务识别"></a>业务服务识别</h4><p>业务服务识别，是为后续系统实现进行的基于业务边界的模块拆分分析，业内常见的拆分方法有：</p><ul><li><strong>基于限界上下文进行拆分：</strong>每个限界上下文为一个服务，优点是每个服务都很小，代码量少；缺点是拆分粒度太细，导致服务数量过多，增加架构设计的复杂度和运维成本。</li><li><strong>基于子域进行拆分：</strong>每个子域为一个服务，优点是服务数量相对较少，架构复杂度和运维成本相对更低；缺点是拆分粒度在某些场景下会非常大，导致单个服务变成“小单体”，增加开发成本和代码分层复杂度。</li><li><strong>基于弹性边界进行拆分：</strong>这个方式是云原生时代新的拆分方式，通过针对服务实例的弹性伸缩的功能性需求或非功能性需求，以弹性边界为决定性参考，结合子域和限界上下文的分析，进行模块拆分。这种方式的优点是，服务粒度和数量适中，更贴近实际需要，开发和运维成本均衡；缺点是引入了一个更贴近运营需求和技术实现的参考维度，增加了系统架构的能力要求和复杂度（这种方法我取自于ThoughtWorks中国区CTO徐昊）。</li></ul><p>从我的实战检验来看，我刻意的选择“基于弹性边界进行拆分”的方式，因为这种方式的说服力更高，性价比也最高，至于对于架构能力和复杂度的要求嘛……对于一个技术顾问和云原生时代的架构师来说，这应该都不是问题才对……</p><p><strong>通过对于业务服务进行划分，团队能够获得对软件架构模块拆分的直接指导，并且还能够依据“逆康威定律”依据架构结果进行开发团队的划分和组建。</strong></p><p>业务服务识别过程的产出物，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050358.png" alt="业务服务划分"></p><h4 id="业务服务接口能力识别"><a href="#业务服务接口能力识别" class="headerlink" title="业务服务接口能力识别"></a>业务服务接口能力识别</h4><p>在识别和划分了业务服务之后，我们需要针对每一个业务服务，基于领域建模时聚合的决策命令，补全和定义每一个业务服务对外暴露的接口能力，这种接口能力一般就是两类：</p><ul><li>写类型的接口能力</li><li>读类型的接口能力</li></ul><p>而在这个过程中，由于我们还是处于协作设计的阶段，忽略具体技术实现细节，所以我们并不关心接口的实现方式，例如：接口的设计风格、接口的协议、接口的地址、接口的数据结构、是否是事件驱动、是否用消息队列、是同步接口还是异步接口等。这些东西都是在后续技术实现阶段进行的更详细的设计过程。</p><p><strong>通过对业务服务的接口能力进行识别，团队能够提前定义业务服务的接口概要设计方案，为后续负责具体开发的团队提供直接的输入，方便他们进行接口的详细设计。</strong></p><p><em>PS：很多老的DDD设计方式，在这时候往往都会使用Swagger来定义基于RESTful Web API的接口，来实现“API驱动开发（API Driven Development）”。一方面正如前述所说，这都是技术实现细节，提前考虑技术实现细节一方面会增加协作设计阶段的成本，另一方面会干扰领域驱动设计的过程。另一方面，当今的微服务，RESTful Web API这种同步接口的设计，已经不再是最优的默认接口设计风格，内部服务间通过gRPC或消息队列进行通信，对前端服务使用GraphQL等技术实现查询式接口，已经逐渐成为了新的趋势，而RESTful Web API则主要用于对外部服务暴露开放接口的场合。所以，我改为了只对接口能力进行识别，忽略技术实现细节。</em></p><p>业务服务接口能力识别过程的产出物，如下图所示：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-15-050408.png" alt="业务服务接口能力识别"></p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><p>在完成了战略设计和战术设计之后，需要众多关键角色集中投入的协作设计过程，就告一段落了。剩下的与具体技术要求更紧密的详细设计过程，刻意交由具体负责业务服务开发的团队去进行后续的设计和实现。</p><p>技术实现阶段要做的事情，包括且不限于：</p><ul><li>补全技术组件：补全为了支撑系统实现的关键技术型组件，例如客户端、BFF（Backend for Frontend）、ACL（Anticorruption Layer，防腐层）等，完善系统应用类组件（需要分清应用和基础设施的区别）。</li><li>技术选型：选择适合的技术栈或工具。</li><li>API详细设计：选择适合的通讯方式、API设计风格和开发框架，利用契约测试或可视化文档对API进行详细设计。</li><li>分层架构设计：采用符合领域驱动设计风格（或者其它符合整洁架构思想的）的分层架构思想，设计单个服务的架构。</li><li>领域模型类设计：参考领域模型的设计，利用面向对象的语言设计具体的类。</li><li>持久化设计：参考领域模型的设计和实际的持久化相关指标，对持久化组件（例如数据库）进行选型和设计。</li><li>制定测试策略：针对实际需要和性价比，设计适合的测试策略，以守护架构设计。</li><li>……（其它）</li></ul><p><strong>需要特别注意的是：哪些东西属于技术实现细节？哪些东西属于抽象业务？这个判断将会贯穿整个DDD的分段式协作设计过程，任何过早进行技术实现细节的思考和讨论，都有极大的风险导致领域驱动走偏。</strong></p><p>所以，在实战过程中，我通常采用一个非常有效的方式来提醒大家：</p><p>拉一个写着“绝不提前考虑技术实现”的横幅贴在墙上……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容，就是关于我的“DDD分段式协作设计”的介绍，具体的操作步骤和注意事项，欢迎参考<a href="https://huhao.dev/posts/130bb570/">先前文章中提供的操作手册</a>。</p><p>当然，从2020年起，我也开始组织公开的“领域驱动设计练功房”培训课程（收费课程），在这个培训课程中，我们不但会通过实战的方式让大家体会协作设计的过程，也会通过测试驱动开发（TDD）的方式带领大家体验DDD技术实现过程中有关分层设计的方式。</p><p>在培训和线上社群中，我也会更多的分享实战中的案例和经验，为参与的学员答疑解惑：</p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-16-123317.jpg" alt="领域驱动设计练功房（第一期）" style="zoom:50%;" /><p>当然，有任何问题和建议，欢迎大家通过文章下方的评论进行交流，同时关注后续文章。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://huhao.dev/posts/130bb570/">领域驱动实战思考（一）：用TDD思想对DDD的协作设计过程进行基准化</a></li><li><a href="https://huhao.dev/posts/58fe0824/">领域驱动实战思考（二）：用分段思想改进那些混乱的战略设计和战术设计</a></li></ul><hr><h2 id="欢迎关注我的个人公众号"><a href="#欢迎关注我的个人公众号" class="headerlink" title="欢迎关注我的个人公众号"></a>欢迎关注我的个人公众号</h2><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-20-wechat.png" alt="枪炮与玫瑰"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我的&lt;a href=&quot;https://huhao.dev/posts/58fe0824/&quot;&gt;上一篇文章&lt;/a&gt;中，给大家介绍了我在实践中对于DDD设计过程进行梳理的思考。本篇则是向大家整体介绍一下我的“DDD分段式协作设计”的步骤和内容。&lt;/p&gt;
&lt;p&gt;同时，该方法的基准化操作手册，也在曾经的一篇文章中&lt;a href=&quot;https://huhao.dev/posts/130bb570/&quot;&gt;公开提供了下载&lt;/a&gt;，可以作为更细化的内容进行参考和使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于DDD的相关概念和设计方法极多，相比其他市场上所能见到的操作手法，我在这里向大家所介绍的方法，更加聚焦如何能够确保达到“绝大多数人的60分”， 而非“极少数人的100分”，也就是说，我更加注重的是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;步骤间的连贯性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法的可操作性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实践的可落地性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与新技术的匹配性（例如云原生）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为此，我尽可能的通过实战检验，在一些需要凭借经验进行综合判断的场景，尽可能的提供虽然不完美但是可以降低选择成本的唯一选项或解释，从而争取让一线实施人员避免“二选一”或“看具体情况再说”这样莫能两可的纠结。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是，不同的咨询师在实施DDD的设计过程中手法都不一样，我仅是从我所实施过的咨询项目出发，提供了一种经反复验证可工作的方式，并不代表本方法是唯一正确的。&lt;/p&gt;
&lt;p&gt;在这里仅供参考，也欢迎大家进行交流。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Domain Driven Development" scheme="https://huhao.dev/categories/Domain-Driven-Development/"/>
    
    
      <category term="DDD" scheme="https://huhao.dev/tags/DDD/"/>
    
      <category term="战略设计" scheme="https://huhao.dev/tags/%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="战术设计" scheme="https://huhao.dev/tags/%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动实战思考（二）：用分段思想改进那些混乱的战略设计和战术设计</title>
    <link href="https://huhao.dev/posts/58fe0824/"/>
    <id>https://huhao.dev/posts/58fe0824/</id>
    <published>2020-01-13T14:30:28.000Z</published>
    <updated>2020-01-13T14:30:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年，在我<a href="https://huhao.dev/posts/130bb570/">对DDD进行基准化</a>的过程中，遇到过非常多的挑战，其中一个便是：</p><p><strong>DDD的设计过程，到底应该分为多少个阶段？每个阶段做什么事情？</strong></p><p>这个困惑来自于书本上，以及其他咨询师在咨询过程中对于DDD设计和操作的差异：</p><ul><li>有的人会从电梯演讲和用户地图开始做设计和分析；</li><li>有的人会从事件风暴开始做设计和分析；</li><li>有的人会从子域开始做设计和分析；</li><li>有的人会从限界上下文开始做设计和分析；</li><li>有的人会直接从领域建模的聚合、实体、值对象开始做设计和分析；</li><li>当然，还有的人会使用“名词动词法”直接从用例描述开始做设计和分析。</li></ul><p>对于实际的学习者和使用者来说，这种混乱的操作手法所形成的不一致和不流畅体验，对于坚持进行DDD设计和减少吵架来说，简直是一种毁灭性的影响。</p><p>在这个过程中，最让我感触深刻的，是在于大家在落地DDD的时候，使用了大量具有“二义性”的词汇，讽刺的是，这与DDD所强调的统一语言是背道而驰的。</p><p>其中对于上述混乱影响最大的因素之一，就是大家对于DDD的“战略设计”和“战术设计”认知不一致（甚至说是混沌）的问题。</p><p>所以，这篇文章，就是围绕这两个概念，来说一说我是如何在基准化的过程中解决这个问题，统一并形成较为流畅的分段式的设计过程的。</p><a id="more"></a><h2 id="混乱的战略设计和战术设计"><a href="#混乱的战略设计和战术设计" class="headerlink" title="混乱的战略设计和战术设计"></a>混乱的战略设计和战术设计</h2><p>一谈起“战略设计”和“战术设计”，你一定会听到“问题域”、“方案域”、“实现域”等名词。</p><p>我的同事肖然在经过反复理解和提炼之后，曾经提出过一个用于解释“问题与方案”、“战略与战术”的“元模型”：</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-DDD-Essence.png" alt="从问题/解决方案和战略/战术维度分析DDD元模型的元素"></p><p>这个模型其实对于具备多维思维和对DDD有着深入理解的人来说，是一种不错的可视化辅助理解手段（划分的合理性仅供参考）。但是在成为更多的咨询师做DDD咨询或培训时开篇必用的材料之后，事情就变得诡异了。因为这个元模型对于咨询师或者培训师是一个比较好的记忆工具，而不是用来给别人解释的适合的工具。</p><p>当没有意识到这一点的人在使用这个模型给客户解释的时候，会向客户描述成：“问题域的战略设计”、“问题域的战术设计”、“解决方案域的战略设计”以及“解决方案的战术设计”。</p><p>经过实战证明，这种方式不到1分钟，就能让客户及对DDD理论没有深入了解的人晕菜，屡试不爽。</p><h3 id="它们是从哪儿来的？"><a href="#它们是从哪儿来的？" class="headerlink" title="它们是从哪儿来的？"></a>它们是从哪儿来的？</h3><p>在搞清楚这个问题之前，我们先要追本溯源，看看这些概念是从哪里来的。</p><h4 id="问题域-方案域-实现域"><a href="#问题域-方案域-实现域" class="headerlink" title="问题域 / 方案域 / 实现域"></a>问题域 / 方案域 / 实现域</h4><p>什么是问题域？什么是方案域？什么是实现域？</p><p>非常有意思的是，以上名词在我搜索的过程中，能够搜到的结果绝大多数都是和软件系统的业务分析及领域驱动设计相关的，当然他们还有很多不同的翻译或者别称。具体到底最初是哪里定义了这三个词汇，我目前还无从查证。但仅从字面上来说，<strong>这是其实是一个非常自然的，人类解决问题的过程</strong>。</p><p>我不想用书本上或者别人博客里的概念进行重复介绍，我更喜欢用我在做咨询的时候总是会用一个屡试不爽的小测试来让大家体会。</p><p>首先，我会问：</p><blockquote><p>我：“我饿了。”</p></blockquote><p>然后，我会让大家根据这个问题来接一句话去将对话接下去，这时候很多人会这样说：</p><blockquote><p>客户A：“你吃什么？”<br>客户B：“走，一起吃饭去？”<br>客户C：“你想什么时候吃？”<br>……</p></blockquote><p>以上就是绝大多数人所习惯的基于方案而非问题进行回答的方式。但一个更正确的，体现问题驱动的答法应该是：</p><blockquote><p>某善于问题驱动的客户：“你为什么饿了？”</p></blockquote><p>这时候，接下来我的回答有可能是：</p><blockquote><p>我：“我中午加班开会，时间比较紧，下午还要来给大家做工作坊，所以中午没吃饭，现在感觉有些低血糖。”</p></blockquote><p>最后，得到的答案往往就会跟之前有很大不同：</p><blockquote><p>客户A：“要不要我给你找点吃的你先垫一垫？”<br>客户B：“要不我们先暂停工作坊你去吃点东西？”<br>……</p></blockquote><p>在这个例子中，包含几个不同的部分：</p><ul><li>待解决问题：我饿了</li><li>问题澄清的结果：中午加班开会，时间比较紧，下午还要来给大家做工作坊，所以中午没吃饭，现在感觉有些低血糖</li><li>解决方案：先垫一垫 or 暂停工作坊去吃东西</li><li>实现细节：先吃块儿巧克力 or 去外面吃快餐</li></ul><p>让我给予一个简单而非严谨的总结：</p><p><strong>问题需要被澄清，问题澄清的结果决定解决方案，问题往往会有多种解决方案，每种解决方案的落地过程是实现细节。</strong></p><p>那么，所谓的“问题域”无非就是“待解决问题的集合”，“方案域”便是“解决方案的集合”，“实现域”便是“实现细节的集合”。而<strong>“领域驱动”</strong>，其实就是<strong>“问题驱动”</strong>——<strong>从澄清关键业务问题开始，逐渐寻找适合的解决方案，再到确定实现细节的过程。</strong></p><h4 id="战略设计-战术设计"><a href="#战略设计-战术设计" class="headerlink" title="战略设计 / 战术设计"></a>战略设计 / 战术设计</h4><p>说到“战略设计”和“战术设计”，这两个词的来源也非常有意思，让我们来说说。</p><p>（以下仅以国内翻译过的书籍来介绍）</p><h5 id="Eric-Evans最初的解释"><a href="#Eric-Evans最初的解释" class="headerlink" title="Eric Evans最初的解释"></a>Eric Evans最初的解释</h5><p>“战略设计（strategic design）”一词最早来自于2004年Eric Evans最初的《领域驱动设计：软件核心复杂性应对之道》一书的最后一个部分（第四部分：战略设计）。</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-book-ddd.jpg" alt="《领域驱动设计：软件核心复杂性应对之道》"></p><p>他的原意是：</p><blockquote><p>战略设计：一种针对系统整体的建模和设计决策。这样的决策影响整个项目，而且必须由团队来制定。</p></blockquote><p>在Eric Evans的书中，战略设计会优先关注限界上下文以及限界上下文之间的协作关系，然后通过精炼的方式得到核心域和通用域等“模式”。而在整个书中，其实有关于统一语言和建模的细节都是在全书的前三个部分讨论的，</p><p>也就是说，在最初的这本书中，并没有“战术设计”一词，而Eric Evans是先说的“战术”后说的“战略”。因为他认为：</p><blockquote><p>随着系统的增长，它会变得越来越复杂，当我们无法通过分析对象来理解系统的时候，就需要掌握一些操纵和理解大模型的技术了。本书的这一部分将介绍一些原则。遵循这些原则，就可以对非常复杂的领域进行建模。大部分这样的决策都需要由团队来制定，甚至需要多个团队共同协商制定。这些决策往往是把设计和策略综合到一起的结果。</p></blockquote><p>换句话说，其实他先是介绍的“简单”的系统的领域驱动设计和建模方法，而在最后才介绍的是“复杂”的系统的领域驱动设计和分析方法。</p><h5 id="Vaughn-Vernon的发展"><a href="#Vaughn-Vernon的发展" class="headerlink" title="Vaughn Vernon的发展"></a>Vaughn Vernon的发展</h5><p>2013年，Vaughn Vernon在实施了很长时间以“实现领域驱动设计”为核心内容的工作坊之后，出版了《实现领域驱动设计》一书，在这本书中，他按照从宏观到微观，从问题到方案再到实现的方式进行了叙述，发展并完善了DDD的理论和概念，当然也引入了“问题空间”和“解决方案空间”这两个词。</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-book-iddd.jpg" alt="《实现领域驱动设计》"></p><p>他认为，在DDD的“战略设计中”，还需要考虑“问题空间”和“解决方案空间”这样的维度，其中子域（他在“核心域”和“通用域”之间加入“支撑域”来避免两个极端）属于“战略设计”对于“问题空间”的分析方式，而限界上下文则是属于“战略设计”对于“解决方案空间”的分析方式。</p><p>至于“战术设计”一词，hum……当时还没出现呢……</p><p>那么“战术设计”这个词，到底是什么时候才出现的呢？</p><h5 id="Scott-Millett与Nick-Tune被“忽略”的澄清"><a href="#Scott-Millett与Nick-Tune被“忽略”的澄清" class="headerlink" title="Scott Millett与Nick Tune被“忽略”的澄清"></a>Scott Millett与Nick Tune被“忽略”的澄清</h5><p>说实话，“战术设计”这个大家看到现在基本都已经感受到是什么了的东西，到底什么时候由谁提出的，已经难以追溯，但是，至少有一本书出现了……</p><p>在2015年，Scott Millett和Nick Tune出版了《领域驱动设计模式、原理与实践》一书，这本书更加全面和细致的介绍了在实现DDD的过程中的思考和方法。</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-book-3pddd.jpg" alt="《领域驱动设计模式、原理与实践》"></p><p>然而很可惜的是，这一本书的中文版已经“绝版了”，说明至少在中国，大家的注意力都被《实现领域驱动设计》带跑了，逢人便提IDDD（书名的缩写），却很少有人提到前述的这一本（当然，我强烈建议对照看英文版，中文版翻译的实在是……）。</p><p>在这本书中，作者将全书分为了四个部分:</p><ol><li>领域驱动设计的原则与实践</li><li>战略模式：在限界上下文之间通信</li><li>战术模式：创建有效的领域模型</li><li>有效应用程序的设计模式</li></ol><p>至此，在DDD的系列书籍中，终于出现了“战术设计/模式”一词，Scott Millett和Nick Tune把领域模型的设计全部清晰的纳入到了“战术设计”之中。</p><h3 id="为什么大多数人会难以理解？"><a href="#为什么大多数人会难以理解？" class="headerlink" title="为什么大多数人会难以理解？"></a>为什么大多数人会难以理解？</h3><p>好吧，大家能看到这里已经很不容易了，让我来为大家做总结并回答一下为什么大多数人会难以理解前述的两个维度的概念呢？</p><p>我是这么看的，之所以难以理解，问题来自于两个方面，让我们分别来说。</p><h4 id="DDD“依然年轻”"><a href="#DDD“依然年轻”" class="headerlink" title="DDD“依然年轻”"></a>DDD“依然年轻”</h4><p>DDD虽然从2004年开始，截止到刚刚过去的2019年，已经有15年的发展，但是15年来，虽然软件架构和设计的新思想层出不穷，复杂度也越来越高。</p><p>直到2014年，以Martin Fowler为代表，在博客上彻底点燃微服务设计这个“燎原之火”之后，微服务所带来的软件系统的复杂度成倍提升才使得人们又重新关注，并开始根据新的形势认真思考DDD如何落地（到如今，几乎逢领微服务设计的书，必谈DDD）。</p><p>从前面的介绍和几本书的内容发展我们可以看到，DDD思想发展的时间跨越很大，语言和理解的统一也并不顺畅，很多概念的清晰化都是最近几年才密集出现。</p><p>尤其在中国，发展更为滞后。这个圈子里，有机会深入思考和深耕DDD规模化落地的人也不多。</p><h4 id="概念理解有难度"><a href="#概念理解有难度" class="headerlink" title="概念理解有难度"></a>概念理解有难度</h4><p>让我们回顾这些概念和抽取其中的关键词语，我们会看到这两波东西是完全不同维度的东西：</p><ul><li>解决问题的层次：战略、战术</li><li>解决问题的步骤：问题、方案、实现</li></ul><p>之所以难以理解，是因为这些概念在现有的书籍、文章和实际操作中，是交织在一起的（可以想象一个概念的“大泥球”），而绝大多数人并不擅长（或者说并不熟练）以下三种思维方式：</p><ul><li>问题驱动的思考</li><li>分层思维</li><li>多维思考</li></ul><p>所以我们需要甩开这些概念上的反复纠缠，以更加清晰的阶段划分和渐进式的方法来降低门槛，从而让大多数人能够更加容易的理解和入门。</p><h2 id="更合理的“DDD分段式设计”"><a href="#更合理的“DDD分段式设计”" class="headerlink" title="更合理的“DDD分段式设计”"></a>更合理的“DDD分段式设计”</h2><p>为了更好的对DDD的设计过程进行优化，我们必须要重新审视DDD希望解决的问题：</p><blockquote><p><strong>软件核心复杂性</strong></p></blockquote><p>所谓复杂（Complex），按照<a href="https://en.wikipedia.org/wiki/Cynefin_framework" target="_blank" rel="noopener">Cynefin框架</a>的解释是这样的（这里使用了我的同事李彤欣的版本）：</p><blockquote><p><em>“复杂系统：代表可能有，也可能没有解决方案的系统，充满未知和不确定性。因果关系往往在事后才能感知，刚开始可能毫无头绪。应对方式是探索 - 感知 - 响应。在允许试错的前提下，先做小范围实验和尝试，等待某些规律和指导涌现出来后，再来认知和评估，然后响应。”</em></p></blockquote><p>而从我的观察和理解来说，这种复杂问题最直接的影响就是：<strong>其复杂程度已经超出了个人所能够理解、分析和解决的范围</strong>。我总结了三个针对“复杂性”的典型特征：</p><ul><li>业务流程长</li><li>业务场景多</li><li>业务概念多</li></ul><p>要想解决复杂的问题，首当其冲的不是如何进行分析，而是引入更多的人，利用更多的大脑来共同解决复杂问题。当从一个人变成多个人的时候，那么问题就来了：别人的大脑长在别人的脑袋里，我怎么知道他想的是什么？他所理解的和我理解的一样吗？</p><p>正因为多人共同做事情时，会出现沟通和理解上的障碍，所以，DDD给出了一个关键思想：<strong>统一语言（Ubiquitous Language）</strong>。</p><p><strong>而统一语言的方式，则是通过领域专家与技术专家通力合作，针对业务问题进行协作分析和设计，通过迭代式的探索、发现和碰撞得来的</strong>。</p><p>所以，以统一语言为核心，通过协作设计的方式，对业务问题进行分析和澄清，就应该是DDD设计过程的第一个阶段。在这个阶段中，我们围绕业务问题、场景和流程来进行探索，通过限界上下文寻找概念二义性的边界，划分问题子域，从而在宏观（战略）层面降解系统理解上的复杂度。</p><p>我将这第一个阶段称之为：<strong>DDD分段式协作设计的战略设计阶段</strong>。</p><p>在这个过程中，我们首先需要使用“事件风暴工作坊”的方式，对业务流程进行系统实现视角下的抽象分析。然后，根据分析的结果，对领域概念的二义性边界进行识别，最终划定问题子域。</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-ddd-3step-1.png" alt="DDD分段式协作设计：战略设计"></p><p>当这一宏观层的分析和设计结束后，我们就需要降低（细化）一个层面，对问题子域和限界上下文内部进行更细化的分析和抽象，通过领域建模的方式，将业务抽象为以“聚合（Aggregate）”进行封装和隔离的一系列领域模型进行承载。然后，基于系统实现的高阶视角出发，参考云原生的弹性边界需求等输入，初步识别出业务服务的划分，并且识别每个业务服务的对外接口能力。</p><p>我将这第二个阶段，称之为：<strong>DDD分段式协作设计的战术设计阶段</strong>。</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-ddd-3step-2.png" alt="DDD分段式协作设计：战术设计"></p><p>需要注意的是，在前两个阶段，我们都依然是通过从宏观到微观（从战略到战术）的方式，对业务问题进行了分层的分析和设计。所以在这两个阶段中，我们是忽略了一切技术实现细节，以防止技术实现细节干扰“领域驱动”的。</p><p>同时，由于“协作设计”需要投入一定的人天进行集中式的封闭设计，所以在成本上难以长时间进行投入，而技术实现的维度和方式又是种类繁多和及其详细的（例如API详细设计、UML设计、数据库设计、运维与部署方案……等等）。</p><p>所以，可以将前两个阶段的产出，交由根据“逆康威定律”划分的不同特性/产品团队，由这些团队进行进一步的详细分析和设计，最终予以实现。</p><p>我将这第三个阶段，称之为：<strong>DDD分段式协作设计的技术实现阶段</strong>。</p><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-ddd-3step-3.png" alt="DDD分段式协作设计：技术实现"></p><p>至此，便有了更加平顺的DDD设计方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据实践中的思考，以“统一语言”为解决复杂问题的核心目标，以“协作设计”为关键手段，我将DDD的设计过程重新梳理和优化为了以下三个阶段：</p><ol><li><strong>战略设计阶段</strong>：对业务问题进行宏观分析和设计。</li><li><strong>战术设计阶段</strong>：根据战略设计分析结果进行细化和建模。</li><li><strong>技术实现阶段</strong>：根据实现需要进行细化分析和设计。</li></ol><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-13-ddd-3step-0.png" alt="DDD分段式协作设计总览"></p><p>在这个过程中，主要的改进方式，首先就是利用分层的手法，通过聚焦从宏观到微观再到具体的方式，降低对抽象的分类方法的关注，化解对两类概念维度的交叉。然后，再通过定义每个阶段要解决的问题，内聚相关的分析方法，使得每个阶段都能有一些在阶段内闭环性的产出。</p><p>这样的话，因为阶段目标清晰且产出内聚，所以可以根据实际需要选择协作设计的深入程度——我遇到过有些客户，因为种种原因，只希望能够先快速的知道我需要根据DDD的思想拆分多少个模块，那么就可以先只做战略设计阶段。如果其中某个模块希望进一步细化指导建模和接口设计，那么就可以继续局部进入到战术设计阶段。最后，再根据实际需要去分团队进行技术实现。</p><p>我们一定要记住：<strong>DDD是通过协作来达成统一语言从而应对复杂性的，组织背景下的软件开发是一种团队集体运动</strong>。</p><p>所以基于以上观点，我会比较刻意的不提倡以下几种DDD的设计过程：</p><ul><li>先分析子域 / 先分析限界上下文：业务都未澄清，理解和语言都还没统一，怎么能拆明白？</li><li>名词动词法 / 直接进行领域建模：大规模吵架和拍脑袋……</li></ul><p>对于以上的分段式设计方法，经过了一年多的实战检验，证明能够被在绝大多数场景下适配和快速复用。在这里给大家分享了我在这个过程中的思考，抛砖引玉，希望能够有更多DDD的推动者提出宝贵的建议，共同推动DDD在中国的成熟和发展。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://huhao.dev/posts/130bb570/">用TDD思想对DDD的协作设计过程进行基准化</a></li><li><a href="https://insights.thoughtworks.cn/subdomain-and-bounded-context/" target="_blank" rel="noopener">当Subdomain遇见Bounded Context</a></li><li><a href="https://en.wikipedia.org/wiki/Cynefin_framework" target="_blank" rel="noopener">Cynefin Framework</a></li></ul><hr><h2 id="欢迎关注我的个人公众号"><a href="#欢迎关注我的个人公众号" class="headerlink" title="欢迎关注我的个人公众号"></a>欢迎关注我的个人公众号</h2><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-20-wechat.png" alt="枪炮与玫瑰"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2019年，在我&lt;a href=&quot;https://huhao.dev/posts/130bb570/&quot;&gt;对DDD进行基准化&lt;/a&gt;的过程中，遇到过非常多的挑战，其中一个便是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DDD的设计过程，到底应该分为多少个阶段？每个阶段做什么事情？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个困惑来自于书本上，以及其他咨询师在咨询过程中对于DDD设计和操作的差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有的人会从电梯演讲和用户地图开始做设计和分析；&lt;/li&gt;
&lt;li&gt;有的人会从事件风暴开始做设计和分析；&lt;/li&gt;
&lt;li&gt;有的人会从子域开始做设计和分析；&lt;/li&gt;
&lt;li&gt;有的人会从限界上下文开始做设计和分析；&lt;/li&gt;
&lt;li&gt;有的人会直接从领域建模的聚合、实体、值对象开始做设计和分析；&lt;/li&gt;
&lt;li&gt;当然，还有的人会使用“名词动词法”直接从用例描述开始做设计和分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于实际的学习者和使用者来说，这种混乱的操作手法所形成的不一致和不流畅体验，对于坚持进行DDD设计和减少吵架来说，简直是一种毁灭性的影响。&lt;/p&gt;
&lt;p&gt;在这个过程中，最让我感触深刻的，是在于大家在落地DDD的时候，使用了大量具有“二义性”的词汇，讽刺的是，这与DDD所强调的统一语言是背道而驰的。&lt;/p&gt;
&lt;p&gt;其中对于上述混乱影响最大的因素之一，就是大家对于DDD的“战略设计”和“战术设计”认知不一致（甚至说是混沌）的问题。&lt;/p&gt;
&lt;p&gt;所以，这篇文章，就是围绕这两个概念，来说一说我是如何在基准化的过程中解决这个问题，统一并形成较为流畅的分段式的设计过程的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Domain Driven Development" scheme="https://huhao.dev/categories/Domain-Driven-Development/"/>
    
    
      <category term="DDD" scheme="https://huhao.dev/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动实战思考（一）：用TDD思想对DDD的协作设计过程进行基准化</title>
    <link href="https://huhao.dev/posts/130bb570/"/>
    <id>https://huhao.dev/posts/130bb570/</id>
    <published>2019-12-21T08:30:28.000Z</published>
    <updated>2019-12-21T08:30:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这一年聚焦DDD设计，尤其是DDD的协作设计工作坊的咨询工作中，我发现客户同很多咨询顾问之间总是存在以下冲突：</p><ul><li><strong>体验的“一致性”冲突</strong><ul><li>客户：希望不同的顾问在售卖方法论的时候解释能一致；</li><li>顾问：认为每个人对方法论的认识和理解本身就不同，很难做到一致。</li></ul></li><li><strong>服务的“标准化”冲突</strong><ul><li>客户：希望顾问能够将所售卖的方法论进行标准化；</li><li>顾问：认为顾问所售卖的方法论本身非常灵活，需要 By Experience 依据不同的情况进行适配，标准化是做不到，并且也是不应该做的。</li></ul></li></ul><p>结合我曾经在ThoughtWorks近4年的人员培养和教学经验，和这几年来的咨询经验，我能够理解客户这样要求，是因为希望能够实现方法论的规模化落地。而<strong>在方法论规模化落地的过程中，一个很重要的问题，就是绝大多数能力一般的人，都更习惯于依据“明确的指令”进行工作，而不是依赖自己“有限的经验”和“莫能两可的方法论”</strong>。</p><p>这篇文章就是记录我是如何来解决这个问题的。</p><a id="more"></a><h2 id="我的基准化思维框架"><a href="#我的基准化思维框架" class="headerlink" title="我的基准化思维框架"></a>我的基准化思维框架</h2><p>对DDD这样的方法论进行“按部就班”式的基准化梳理，从而形成“基准化的操作”，以提供“明确的指令”，说起来简单，做起来却没有想象中容易。绝大多数的顾问虽然能够对方法论进行阶段性拆分，但是却没有能够将方法论进行细粒度的拆分和验证。</p><p>从我的观察来看，之所以造成这个问题，主要原因来自几个方面：</p><ul><li><strong>对方法论的深入研究不够：</strong>在售卖方法论的时候，现学现卖。</li><li><strong>缺乏反复的思考和打磨：</strong>缺乏机会进行反复验证和优化，或者注意力不够聚焦。</li></ul><p>还有一个很重要的原因，就是<strong>绝大多数技术顾问可能脱离写代码这件事情太久了，没有意识到对方法论基准化非常像我们开发软件的过程</strong>：</p><ul><li>首先，都是需要从客户需要出发，明确交付目标的价值和内容。</li><li>然后，以Tasking思想和阶段性验收条件为着眼点，将目标拆解为不同的阶段。</li><li>接下来，对每个阶段进行细化的实现，保证每个阶段的验收条件在实现过程中可以通过最简单的方式达成。</li><li>最后，产出第一版最小基准化内容，通过不断的适配和打磨，进行迭代式的改进，或者较大幅度的修改（类似需求变更）。</li></ul><p>更重要的是，以上这个过程，是可以用“测试驱动开发（Test Driven Development）”的思想来做的！</p><h2 id="利用TDD的方式进行DDD设计过程的基准化"><a href="#利用TDD的方式进行DDD设计过程的基准化" class="headerlink" title="利用TDD的方式进行DDD设计过程的基准化"></a>利用TDD的方式进行DDD设计过程的基准化</h2><p>那么，我是怎样用TDD的思想，对DDD的设计过程进行基准化的呢？在这一年，通过大大小小十数个咨询项目，我是这样做的：</p><ul><li>第一步，我通过在不同客户项目的实践中打磨和定义了每个阶段清晰的输出件，产出了《DDD工作坊准入条件和产出物图例》。<strong>这一步就相当于通过Tasking确定程序的输入和输出，以及定义测试驱动开发中的测试用例。</strong></li><li>第二步，在确定了输入输出后，我继续通过不同项目的不断打磨，基准化了每一个阶段的操作步骤，并把每一步细化到概念介绍、操作步骤、过程图例、要点提示四个部分，产出了《DDD工作坊操作手册》。<strong>这一步就相当于通过测试驱动的方式，进行了程序“处理”过程的实现，并且还通过小步迭代的方式，对操作过程进行了一遍又一遍的迭代。</strong></li><li>第三步，在整个操作手册完成之后，基于操作手册，重新梳理抽象出了适配这个操作手册的最简单和通常的概念，并从整个宏观上优化和定义了新的DDD分段式设计（战略设计阶段、战术设计阶段、技术实现阶段），解决了之前所有我所参与过的DDD培训所看到的知识体系凌乱，不统一，不顺畅等问题，让概念讲解部分最小化，产出了《DDD工作坊概念讲解》课件。<strong>这一步就相当于程序设计和开发过程中，通过高度抽象，进行分层架构并实现架构演进的过程。</strong></li><li>第四步，通过项目开发实践和进一步总结，结合多种以领域为核心的分层架构思想，不断打磨形成了适配整个基准化DDD的基准化代码样例（<a href="https://github.com/howiehu/ddd-architecture-samples）。实现了代码化落地。" target="_blank" rel="noopener">https://github.com/howiehu/ddd-architecture-samples）。实现了代码化落地。</a></li><li>第五步，继续通过不断的实践、打磨和总结，产出《DDD成熟度评估标准》。</li></ul><p>这样，就通过实战验证的方式，从确定交付物开始，一步一步的增量式的完成了DDD设计过程的基准化，<strong>这也很像我们做软件设计时通过TDD而达到的“简单设计（增量式设计）”思想。</strong></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>DDD的思想和设计过程，是公开并且没有什么保留意义的，所以，我在这里也选择分享给大家，以便为DDD在中国的落地和完善贡献一份力量。</strong></p><p><strong>同时，我也正在建立一系列的DDD基准化公开材料、社区和培训，我未来会将这些内容逐步发布到Github的“领域驱动”组织之中，地址如下：</strong></p><ul><li><strong><a href="https://github.com/domain-driven" target="_blank" rel="noopener">https://github.com/domain-driven</a></strong></li></ul><p>而文章中所说的基准化的领域驱动设计产出物如下，未来我会继续进行不断的打磨和优化：</p><ul><li><a href="https://pan.baidu.com/s/10eVNdJ0kN5dPZX1On7V5bg" target="_blank" rel="noopener">《DDD工作坊准入条件和产出物图例》</a>（提取码: 9jza）</li><li><a href="https://pan.baidu.com/s/16zP-QFuljJqQeE4PWovG4g" target="_blank" rel="noopener">《DDD工作坊操作手册》</a>（提取码: uu1d）</li><li><a href="https://pan.baidu.com/s/1PnXfqr1RsGG-z9QXTGY4Uw" target="_blank" rel="noopener">《DDD工作坊概念讲解》</a>（提取码: b4ft）</li><li><a href="https://github.com/howiehu/ddd-architecture-samples" target="_blank" rel="noopener">《DDD基准化代码结构样例》</a></li><li>《DDD成熟度评估标准》(还在完善中，请期待)</li></ul><p>对于这些基准化的产出，我已经通过带领7个新咨询师进行了可复用性的验证，这些新咨询师只需要通过我讲解或示范一遍，就能够独立承担后续的DDD设计咨询工作，并且还能够实现概念和手法的一致性。</p><p>至于“By Experience”，则只剩操作者个人经验的高低，和智商的天花板了。</p><hr><h2 id="欢迎关注我的微信公众号"><a href="#欢迎关注我的微信公众号" class="headerlink" title="欢迎关注我的微信公众号"></a>欢迎关注我的微信公众号</h2><p><img src="https://huhao-dev.oss-cn-beijing.aliyuncs.com/2020-01-20-wechat.png" alt="枪炮与玫瑰"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在这一年聚焦DDD设计，尤其是DDD的协作设计工作坊的咨询工作中，我发现客户同很多咨询顾问之间总是存在以下冲突：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;体验的“一致性”冲突&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;客户：希望不同的顾问在售卖方法论的时候解释能一致；&lt;/li&gt;
&lt;li&gt;顾问：认为每个人对方法论的认识和理解本身就不同，很难做到一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务的“标准化”冲突&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;客户：希望顾问能够将所售卖的方法论进行标准化；&lt;/li&gt;
&lt;li&gt;顾问：认为顾问所售卖的方法论本身非常灵活，需要 By Experience 依据不同的情况进行适配，标准化是做不到，并且也是不应该做的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合我曾经在ThoughtWorks近4年的人员培养和教学经验，和这几年来的咨询经验，我能够理解客户这样要求，是因为希望能够实现方法论的规模化落地。而&lt;strong&gt;在方法论规模化落地的过程中，一个很重要的问题，就是绝大多数能力一般的人，都更习惯于依据“明确的指令”进行工作，而不是依赖自己“有限的经验”和“莫能两可的方法论”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章就是记录我是如何来解决这个问题的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Domain Driven Development" scheme="https://huhao.dev/categories/Domain-Driven-Development/"/>
    
    
      <category term="DDD" scheme="https://huhao.dev/tags/DDD/"/>
    
      <category term="TDD" scheme="https://huhao.dev/tags/TDD/"/>
    
      <category term="基准化" scheme="https://huhao.dev/tags/%E5%9F%BA%E5%87%86%E5%8C%96/"/>
    
  </entry>
  
</feed>
